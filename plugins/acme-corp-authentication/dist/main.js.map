{"version":3,"file":"index.js","mappings":"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A;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gBAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iCAAiC,yCAAyC;AAC1E;AACA;AACA,2BAA2B,gEAAgE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B;AAC3B;AACA,wBAAwB,uBAAuB;AAC/C;AACA,4BAA4B,oBAAoB,EAAE,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,SAAS;AACT;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;ACrOa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,kBAAkB,mBAAO,CAAC,GAAiB;AAC3C;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,4BAA4B;AAC5B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;;;;;;ACpCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC,GAAG,2BAA2B,GAAG,sBAAsB;AACvF,kBAAkB,mBAAO,CAAC,GAAiB;AAC3C;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA,sBAAsB;AACtB,2BAA2B;AAC3B;AACA;AACA,CAAC;AACD;AACA,gCAAgC;AAChC;AACA;AACA,CAAC;AACD;;;;;;;AC3Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,kBAAkB,mBAAO,CAAC,GAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;AC1Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,kBAAkB,mBAAO,CAAC,GAAiB;AAC3C;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA,0BAA0B;AAC1B;;;;;;;ACfa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,kBAAkB,mBAAO,CAAC,GAAiB;AAC3C;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB,aAAa;AAClC,4BAA4B;AAC5B;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,uBAAuB;AACvB;AACA;AACA,kBAAkB;AAClB;;;;;;;AClCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ,qBAAqB,mBAAO,CAAC,GAAc;AAC3C,yBAAyB,mBAAO,CAAC,GAAkB;AACnD,kBAAkB,mBAAO,CAAC,GAAiB;AAC3C,iBAAiB,mBAAO,CAAC,GAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sCAAsC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY;AAClD,aAAa;AACb,SAAS;AACT;AACA;AACA,sCAAsC,gBAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA,4BAA4B,UAAU;AACtC,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,YAAY;AACZ;;;;;;;ACjEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa;AACb,qBAAqB,mBAAO,CAAC,GAAc;AAC3C,yBAAyB,mBAAO,CAAC,GAAkB;AACnD,kBAAkB,mBAAO,CAAC,GAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uHAAuH;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kCAAkC,sBAAsB;AACxD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,wBAAwB,aAAa;AACrC;AACA;AACA,yBAAyB,UAAU;AACnC;AACA,6BAA6B;AAC7B;AACA,mCAAmC;AACnC;AACA;AACA,oCAAoC;AACpC;AACA;AACA,mCAAmC;AACnC;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,aAAa;AACb;;;;;;;ACnGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,kBAAkB,mBAAO,CAAC,GAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;;;;;;;ACpBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,yBAAyB,mBAAO,CAAC,GAAkB;AACnD,kBAAkB,mBAAO,CAAC,GAAiB;AAC3C,iBAAiB,mBAAO,CAAC,EAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAsD;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gBAAgB;AAC1D;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;ACjEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,uBAAuB,GAAG,kBAAkB;AAC7D,kBAAkB,mBAAO,CAAC,GAAiB;AAC3C,2BAA2B,mBAAO,CAAC,GAAoB;AACvD;AACA;AACA;AACA;AACA,CAAC,iBAAiB,kBAAkB,kBAAkB;AACtD;AACA;AACA;AACA;AACA,CAAC,sBAAsB,uBAAuB,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qIAAqI;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,wBAAwB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,cAAc;AACd;;;;;;;ACpJa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,kBAAkB,mBAAO,CAAC,GAAiB;AAC3C;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;;;;;;ACpCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,kBAAkB,mBAAO,CAAC,GAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+DAA+D;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;AC/Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,kBAAkB,mBAAO,CAAC,GAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;;;;;;AC1Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ,sBAAsB,mBAAO,CAAC,GAAsB;AACpD,yBAAyB,mBAAO,CAAC,GAAkB;AACnD,kBAAkB,mBAAO,CAAC,GAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY;AACZ;;;;;;;ACrMa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,YAAY,mBAAO,CAAC,GAAK;AACzB;AACA,mBAAmB;AACnB;AACA;AACA,CAAC;AACD;;;;;;;ACTa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,YAAY,mBAAO,CAAC,GAAK;AACzB,mBAAmB;AACnB;AACA;AACA,CAAC;AACD;;;;;;;ACRa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,aAAa;AAC9B,gBAAgB,mBAAO,CAAC,GAAO;AAC/B,aAAa,wBAAwB,mBAAO,CAAC,GAAS;AACtD,cAAc,wBAAwB,mBAAO,CAAC,GAAU;AACxD;;;;;;;ACNa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,kBAAkB,GAAG,0BAA0B,GAAG,wBAAwB,GAAG,0BAA0B,GAAG,iBAAiB,GAAG,YAAY,GAAG,iBAAiB,GAAG,kBAAkB,GAAG,cAAc,GAAG,aAAa,GAAG,YAAY,GAAG,oBAAoB,GAAG,iBAAiB,GAAG,6BAA6B,GAAG,sBAAsB,GAAG,aAAa,GAAG,kBAAkB;AACnY,gBAAgB,mBAAO,CAAC,GAAO;AAC/B,mBAAmB,mBAAO,CAAC,GAAc;AACzC,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH,cAAc,mBAAO,CAAC,GAAS;AAC/B,yCAAwC,EAAE,qCAAqC,yBAAyB,EAAC;AACzG,uBAAuB,mBAAO,CAAC,GAAkB;AACjD,kDAAiD,EAAE,qCAAqC,2CAA2C,EAAC;AACpI,8BAA8B,mBAAO,CAAC,GAAyB;AAC/D,yDAAwD,EAAE,qCAAqC,yDAAyD,EAAC;AACzJ,kBAAkB,mBAAO,CAAC,GAAa;AACvC,6CAA4C,EAAE,qCAAqC,iCAAiC,EAAC;AACrH,oBAAoB,wBAAwB,mBAAO,CAAC,GAAgB;AACpE,aAAa,mBAAO,CAAC,GAAQ;AAC7B,wCAAuC,EAAE,qCAAqC,uBAAuB,EAAC;AACtG,cAAc,mBAAO,CAAC,GAAS;AAC/B,yCAAwC,EAAE,qCAAqC,yBAAyB,EAAC;AACzG,eAAe,mBAAO,CAAC,EAAU;AACjC,0CAAyC,EAAE,qCAAqC,2BAA2B,EAAC;AAC5G,8CAA6C,EAAE,qCAAqC,+BAA+B,EAAC;AACpH,kBAAkB,mBAAO,CAAC,GAAa;AACvC,6CAA4C,EAAE,qCAAqC,iCAAiC,EAAC;AACrH,aAAa,mBAAO,CAAC,GAAQ;AAC7B,wCAAuC,EAAE,qCAAqC,uBAAuB,EAAC;AACtG,kBAAkB,mBAAO,CAAC,GAAa;AACvC,6CAA4C,EAAE,qCAAqC,iCAAiC,EAAC;AACrH,2BAA2B,mBAAO,CAAC,GAAsB;AACzD,sDAAqD,EAAE,qCAAqC,mDAAmD,EAAC;AAChJ,yBAAyB,mBAAO,CAAC,GAAoB;AACrD,oDAAmD,EAAE,qCAAqC,+CAA+C,EAAC;AAC1I,2BAA2B,mBAAO,CAAC,GAAsB;AACzD,sDAAqD,EAAE,qCAAqC,mDAAmD,EAAC;AAChJ,mBAAmB,mBAAO,CAAC,GAAc;AACzC,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH,qBAAqB,mBAAO,CAAC,GAAgB;AAC7C,gDAA+C,EAAE,qCAAqC,uCAAuC,EAAC;AAC9H;;;;;;;ACtCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,iBAAiB,mBAAO,CAAC,EAAU;AACnC;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,eAAe;AACf;;;;;;;ACfa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,OAAO;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ,MAAM,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,KAAK;AACxC;AACA;AACA;AACA,cAAc;AACd;;;;;;;ACvGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,eAAe;AAChC,gBAAgB,mBAAO,CAAC,GAAW;AACnC,2CAA0C,EAAE,qCAAqC,6BAA6B,EAAC;AAC/G,eAAe,mBAAO,CAAC,EAAU;AACjC,0CAAyC,EAAE,qCAAqC,2BAA2B,EAAC;AAC5G;;;;;;;ACPa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,mBAAmB;AAChD;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,0BAA0B;AAC1B;;;;;;;ACVa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,GAAG,oBAAoB,GAAG,kBAAkB,GAAG,aAAa,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,cAAc,GAAG,aAAa,GAAG,iBAAiB,GAAG,0BAA0B,GAAG,oBAAoB,GAAG,wBAAwB,GAAG,6BAA6B,GAAG,sBAAsB,GAAG,kBAAkB,GAAG,cAAc;AACrV,cAAc,mBAAO,CAAC,GAAQ;AAC9B,gCAAgC,mBAAO,CAAC,GAA8B;AACtE;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,oBAAoB;AACpB,aAAa;AACb;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,gBAAgB,sCAAsC,kBAAkB;AACjF,wBAAwB;AACxB;AACA;;AAEO;AACP;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEO;AACP;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;;AAEO;AACP,kCAAkC;AAClC;;AAEO;AACP,uBAAuB,uFAAuF;AAC9G;AACA;AACA,yGAAyG;AACzG;AACA,sCAAsC,QAAQ;AAC9C;AACA,gEAAgE;AAChE;AACA,8CAA8C,yFAAyF;AACvI,8DAA8D,2CAA2C;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA,4CAA4C,yEAAyE;AACrH;;AAEO;AACP;AACA;;AAEO;AACP,0BAA0B,+DAA+D,iBAAiB;AAC1G;AACA,kCAAkC,MAAM,+BAA+B,YAAY;AACnF,iCAAiC,MAAM,mCAAmC,YAAY;AACtF,8BAA8B;AAC9B;AACA,GAAG;AACH;;AAEO;AACP,YAAY,6BAA6B,0BAA0B,cAAc,qBAAqB;AACtG,2IAA2I,cAAc;AACzJ,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,iCAAiC,SAAS;AAC1C,iCAAiC,WAAW,UAAU;AACtD,wCAAwC,cAAc;AACtD;AACA,4GAA4G,OAAO;AACnH,+EAA+E,iBAAiB;AAChG,uDAAuD,gBAAgB,QAAQ;AAC/E,6CAA6C,gBAAgB,gBAAgB;AAC7E;AACA,gCAAgC;AAChC;AACA;AACA,QAAQ,YAAY,aAAa,SAAS,UAAU;AACpD,kCAAkC,SAAS;AAC3C;AACA;;AAEO;AACP;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAEM;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACO;AACP,2BAA2B,sBAAsB;AACjD;AACA;AACA;;AAEA;AACO;AACP,gDAAgD,QAAQ;AACxD,uCAAuC,QAAQ;AAC/C,uDAAuD,QAAQ;AAC/D;AACA;AACA;;AAEO;AACP,2EAA2E,OAAO;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA,wMAAwM,cAAc;AACtN,4BAA4B,sBAAsB;AAClD,wBAAwB,YAAY,sBAAsB,qCAAqC,2CAA2C,MAAM;AAChJ,0BAA0B,MAAM,iBAAiB,YAAY;AAC7D,qBAAqB;AACrB,4BAA4B;AAC5B,2BAA2B;AAC3B,0BAA0B;AAC1B;;AAEO;AACP;AACA,eAAe,6CAA6C,UAAU,sDAAsD,cAAc;AAC1I,wBAAwB,6BAA6B,oBAAoB,uCAAuC,kBAAkB;AAClI;;AAEO;AACP;AACA;AACA,yGAAyG,uFAAuF,cAAc;AAC9M,qBAAqB,8BAA8B,gDAAgD,wDAAwD;AAC3J,2CAA2C,sCAAsC,UAAU,mBAAmB,IAAI;AAClH;;AAEO;AACP,+BAA+B,uCAAuC,YAAY,KAAK,OAAO;AAC9F;AACA;;AAEA;AACA,wCAAwC,4BAA4B;AACpE,CAAC;AACD;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,2CAA2C;AAC3C;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,MAAM,oBAAoB,YAAY;AAC5E,qBAAqB,8CAA8C;AACnE;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,SAAS,gBAAgB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;;;;;;;;;UCzXF;UACA;;UA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","sources":["webpack:///./node_modules/lower-case/dist.es2015/index.js","webpack:///./node_modules/no-case/dist.es2015/index.js","webpack:///./node_modules/pascal-case/dist.es2015/index.js","webpack:///./src/core/create-app-services.ts","webpack:///./src/core/create-builders-services.ts","webpack:///./src/core/create-method-authorize-annotation.ts","webpack:///./src/core/create-seed-development-data.ts","webpack:///./src/core/create-static-file-map.ts","webpack:///./src/core/get-entity-roles-map.ts","webpack:///./src/core/index.ts","webpack:///./src/utils.ts","webpack:///external commonjs2 \"@amplication/code-gen-types\"","webpack:///external node-commonjs \"fs/promises\"","webpack:///external node-commonjs \"path\"","webpack:///./node_modules/@amplication/csharp-ast/src/index.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/Access.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/Annotation.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/Class.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/ClassInstantiation.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/ClassReference.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/CodeBlock.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/CoreClassReference.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/Dictionary.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/Enum.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/Field.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/GenericClassReference.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/Interface.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/Method.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/MethodInvocation.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/Parameter.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/ProgramClass.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/Type.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/dependencies/NUnit.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/dependencies/System.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/dependencies/index.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/ast/index.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/core/AstNode.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/core/Writer.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/core/index.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/utils/assertNever.js","webpack:///./node_modules/@amplication/csharp-ast/src/lib/utils/csharp-support.js","webpack:///./node_modules/tslib/tslib.es6.mjs","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/index.ts"],"sourcesContent":["/**\n * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt\n */\nvar SUPPORTED_LOCALE = {\n    tr: {\n        regexp: /\\u0130|\\u0049|\\u0049\\u0307/g,\n        map: {\n            İ: \"\\u0069\",\n            I: \"\\u0131\",\n            İ: \"\\u0069\",\n        },\n    },\n    az: {\n        regexp: /\\u0130/g,\n        map: {\n            İ: \"\\u0069\",\n            I: \"\\u0131\",\n            İ: \"\\u0069\",\n        },\n    },\n    lt: {\n        regexp: /\\u0049|\\u004A|\\u012E|\\u00CC|\\u00CD|\\u0128/g,\n        map: {\n            I: \"\\u0069\\u0307\",\n            J: \"\\u006A\\u0307\",\n            Į: \"\\u012F\\u0307\",\n            Ì: \"\\u0069\\u0307\\u0300\",\n            Í: \"\\u0069\\u0307\\u0301\",\n            Ĩ: \"\\u0069\\u0307\\u0303\",\n        },\n    },\n};\n/**\n * Localized lower case.\n */\nexport function localeLowerCase(str, locale) {\n    var lang = SUPPORTED_LOCALE[locale.toLowerCase()];\n    if (lang)\n        return lowerCase(str.replace(lang.regexp, function (m) { return lang.map[m]; }));\n    return lowerCase(str);\n}\n/**\n * Lower case as a function.\n */\nexport function lowerCase(str) {\n    return str.toLowerCase();\n}\n//# sourceMappingURL=index.js.map","import { lowerCase } from \"lower-case\";\n// Support camel case (\"camelCase\" -> \"camel Case\" and \"CAMELCase\" -> \"CAMEL Case\").\nvar DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];\n// Remove all non-word characters.\nvar DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;\n/**\n * Normalize the string into something other libraries can manipulate easier.\n */\nexport function noCase(input, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? \" \" : _d;\n    var result = replace(replace(input, splitRegexp, \"$1\\0$2\"), stripRegexp, \"\\0\");\n    var start = 0;\n    var end = result.length;\n    // Trim the delimiter from around the output string.\n    while (result.charAt(start) === \"\\0\")\n        start++;\n    while (result.charAt(end - 1) === \"\\0\")\n        end--;\n    // Transform each token independently.\n    return result.slice(start, end).split(\"\\0\").map(transform).join(delimiter);\n}\n/**\n * Replace `re` in the input string with the replacement value.\n */\nfunction replace(input, re, value) {\n    if (re instanceof RegExp)\n        return input.replace(re, value);\n    return re.reduce(function (input, re) { return input.replace(re, value); }, input);\n}\n//# sourceMappingURL=index.js.map","import { __assign } from \"tslib\";\nimport { noCase } from \"no-case\";\nexport function pascalCaseTransform(input, index) {\n    var firstChar = input.charAt(0);\n    var lowerChars = input.substr(1).toLowerCase();\n    if (index > 0 && firstChar >= \"0\" && firstChar <= \"9\") {\n        return \"_\" + firstChar + lowerChars;\n    }\n    return \"\" + firstChar.toUpperCase() + lowerChars;\n}\nexport function pascalCaseTransformMerge(input) {\n    return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();\n}\nexport function pascalCase(input, options) {\n    if (options === void 0) { options = {}; }\n    return noCase(input, __assign({ delimiter: \"\", transform: pascalCaseTransform }, options));\n}\n//# sourceMappingURL=index.js.map","import { CodeBlock, ProgramClass } from \"@amplication/csharp-ast\";\n\nexport function createAppServices(programClass: ProgramClass): void {\n  programClass.appBlocks.push(\n    new CodeBlock({\n      code: `app.UseApiAuthentication();`,\n    })\n  );\n\n  programClass.appBlocks.push(\n    new CodeBlock({\n      code: `using (var scope = app.Services.CreateScope())\n  {\n      var services = scope.ServiceProvider;\n      await RolesManager.SyncRoles(services, app.Configuration);\n  }`,\n    })\n  );\n\n  programClass.appBlocks.push(\n    new CodeBlock({\n      code: `\n    using (var scope = app.Services.CreateScope())\n    {\n        var services = scope.ServiceProvider;\n        await SeedDevelopmentData.SeedDevUser(services, app.Configuration);\n    }`,\n    })\n  );\n}\n","import { CodeBlock, CsharpSupport,ProgramClass } from \"@amplication/csharp-ast\";\n\nexport function createBuildersServices(\n  resourceName: string,\n  programClass: ProgramClass\n): void {\n  programClass.builderServicesBlocks.push(\n    new CodeBlock({\n      code: `builder.Services.AddApiAuthentication();`,\n    })\n  );\n\n  const swaggerBuilderIndex = programClass.builderServicesBlocks.findIndex((b) =>\n    b.toString().includes(\"AddSwaggerGen\")\n  );\n\n  if (swaggerBuilderIndex === -1) return;\n\n  programClass.builderServicesBlocks[swaggerBuilderIndex] = new CodeBlock({\n    references: [\n      CsharpSupport.classReference({\n        namespace: `${resourceName}.APIs`,\n        name: resourceName,\n      }),\n    ],\n    code: `builder.Services.AddSwaggerGen(options =>\n  {\n      options.UseOpenApiAuthentication();\n      var xmlFilename = $\"{Assembly.GetExecutingAssembly().GetName().Name}.xml\";\n      options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, xmlFilename));\n  });`,\n  });\n}\n","import { Entity, EnumEntityAction } from \"@amplication/code-gen-types\";\nimport { CsharpSupport, Method } from \"@amplication/csharp-ast\";\nimport { getEntityRoleMap } from \"./get-entity-roles-map\";\n\nexport function createMethodAuthorizeAnnotation(\n  method: Method,\n  roles: string\n): void {\n  roles &&\n    method.annotations?.push(\n      CsharpSupport.annotation({\n        reference: CsharpSupport.classReference({\n          name: \"Authorize\",\n          namespace: \"Microsoft.AspNetCore.Authorization\",\n        }),\n        argument: `Roles = \"${roles}\"`,\n      })\n    );\n}\n\nexport function createRelatedMethodAuthorizeAnnotation(\n  entity: Entity,\n  entities: Entity[],\n  fieldPermanentId: string,\n  method: Method,\n  methodType: EnumEntityAction,\n  roles?: string\n): void {\n  const field = entity.fields.find(\n    (field) => field.permanentId === fieldPermanentId\n  );\n\n  const relatedEntity = entities.find(\n    (entity) => entity.id === field?.properties?.relatedEntityId\n  );\n  if (relatedEntity) {\n    const rolesMapping = getEntityRoleMap(relatedEntity, roles);\n    createMethodAuthorizeAnnotation(method, rolesMapping[methodType].roles);\n  }\n}\n","import { dotnetTypes } from \"@amplication/code-gen-types\";\nimport { CodeBlock, CsharpSupport } from \"@amplication/csharp-ast\";\nimport { getPluginSettings } from \"../utils\";\n\nexport function CreateSeedDevelopmentDataBody(\n  resourceName: string,\n  context: dotnetTypes.DsgContext\n): CodeBlock {\n  const { seedUserEmail, seedUserPassword } = getPluginSettings(\n    context.pluginInstallations\n  );\n\n  return new CodeBlock({\n    references: [\n      CsharpSupport.classReference({\n        name: \"Identity\",\n        namespace: \"Microsoft.AspNetCore.Identity\",\n      }),\n      CsharpSupport.classReference({\n        name: \"EntityFrameworkCore\",\n        namespace: \"Microsoft.AspNetCore.Identity.EntityFrameworkCore\",\n      }),\n      CsharpSupport.classReference({\n        name: resourceName,\n        namespace: `${resourceName}.Infrastructure`,\n      }),\n    ],\n    code: `\n      var context = serviceProvider.GetRequiredService<${resourceName}DbContext>();\n      var userStore = new UserStore<IdentityUser>(context);\n      var usernameValue = \"${seedUserEmail}\";\n      var passwordValue = \"${seedUserPassword}\";\n\n      var existingUser = await userStore.FindByEmailAsync(usernameValue);\n      if (existingUser != null)\n      {\n        return;\n      }\n         \n      var user = new IdentityUser\n      {\n          Email = usernameValue,\n          UserName = usernameValue,\n          NormalizedUserName = usernameValue.ToUpperInvariant(),\n          NormalizedEmail = usernameValue.ToUpperInvariant(),\n      };\n      var password = new PasswordHasher<IdentityUser>();\n      var hashed = password.HashPassword(user, passwordValue);\n      user.PasswordHash = hashed;\n      await userStore.CreateAsync(user);\n      \n      var amplicationRoles = configuration\n          .GetSection(\"AmplicationRoles\")\n          .AsEnumerable()\n          .Where(x => x.Value != null)\n          .Select(x => x.Value.ToString())\n          .ToArray();\n      var _roleManager = serviceProvider.GetRequiredService<RoleManager<IdentityRole>>();\n      foreach (var role in amplicationRoles)\n      {\n          await userStore.AddToRoleAsync(user, _roleManager.NormalizeKey(role));\n      }\n      \n      await context.SaveChangesAsync();`,\n  });\n}\n","import { ClassReference, CodeBlock } from \"@amplication/csharp-ast\";\nimport { FileMap, IFile, dotnetTypes } from \"@amplication/code-gen-types\";\nimport { readFile } from \"fs/promises\";\nimport { pascalCase } from \"pascal-case\";\n\nexport async function createStaticFileFileMap(\n  destPath: string,\n  filePath: string,\n  context: dotnetTypes.DsgContext,\n  classReferences?: ClassReference[]\n): Promise<FileMap<CodeBlock>> {\n  const fileMap = new FileMap<CodeBlock>(context.logger);\n\n  if (!context.resourceInfo) return fileMap;\n  const resourceName = pascalCase(context.resourceInfo.name);\n  let fileContent = await readFile(filePath, \"utf-8\");\n  fileContent = fileContent.replaceAll(\"ServiceName\", resourceName);\n\n  const file: IFile<CodeBlock> = {\n    path: destPath,\n    code: new CodeBlock({\n      code: fileContent,\n      references: classReferences && classReferences,\n    }),\n  };\n\n  fileMap.set(file);\n  return fileMap;\n}\n","import {\n  Entity,\n  EnumEntityAction,\n  EnumEntityPermissionType,\n} from \"@amplication/code-gen-types\";\n\nexport function getRelatedFieldRolesMap(\n  entity: Entity,\n  entities: Entity[],\n  fieldPermanentId: string,\n  roleNames?: string\n): Record<\n  EnumEntityAction,\n  {\n    roles: string;\n  }\n> | null {\n  const field = entity.fields.find(\n    (field) => field.permanentId === fieldPermanentId\n  );\n\n  const relatedEntity = entities.find(\n    (entity) => entity.id === field?.properties?.relatedEntityId\n  );\n  if (relatedEntity) {\n    return getEntityRoleMap(relatedEntity, roleNames);\n  }\n  return null;\n}\n\nexport function getEntityRoleMap(\n  entity: Entity,\n  roleNames?: string\n): Record<\n  EnumEntityAction,\n  {\n    roles: string;\n  }\n> {\n  return Object.fromEntries(\n    entity.permissions.map((permission) => {\n      return [\n        permission.action,\n        {\n          roles:\n            permission.type === EnumEntityPermissionType.AllRoles\n              ? roleNames\n              : permission.type === EnumEntityPermissionType.Granular\n              ? permission.permissionRoles\n                  .map((role) => role.resourceRole.name)\n                  .join(\",\")\n              : null,\n        },\n      ];\n    })\n  ) as unknown as Record<EnumEntityAction, { roles: string }>;\n}\n","export {\n  createMethodAuthorizeAnnotation,\n  createRelatedMethodAuthorizeAnnotation,\n} from \"./create-method-authorize-annotation\";\nexport {\n  getEntityRoleMap,\n  getRelatedFieldRolesMap,\n} from \"./get-entity-roles-map\";\nexport { createStaticFileFileMap } from \"./create-static-file-map\";\nexport { createBuildersServices } from \"./create-builders-services\";\nexport { createAppServices } from \"./create-app-services\";\nexport { CreateSeedDevelopmentDataBody } from \"./create-seed-development-data\";\n","import { PluginInstallation } from \"@amplication/code-gen-types\";\nimport { name as PackageName } from \"../package.json\";\nimport { Settings } from \"./types\";\nimport defaultSettings from \"../.amplicationrc.json\";\n\nexport const getPluginSettings = (\n  pluginInstallations: PluginInstallation[]\n): Settings => {\n  const plugin = pluginInstallations.find(\n    (plugin) => plugin.npm === PackageName\n  );\n\n  const userSettings = plugin?.settings ?? {};\n\n  const settings: Settings = {\n    ...defaultSettings.settings,\n    ...userSettings,\n  };\n\n  return settings;\n};\n","module.exports = require(\"@amplication/code-gen-types\");","module.exports = require(\"fs/promises\");","module.exports = require(\"path\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CsharpSupport = void 0;\nconst tslib_1 = require(\"tslib\");\ntslib_1.__exportStar(require(\"./lib/ast\"), exports);\ntslib_1.__exportStar(require(\"./lib/core\"), exports);\nexports.CsharpSupport = tslib_1.__importStar(require(\"./lib/utils/csharp-support\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Access = void 0;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexports.Access = {\n    Public: \"public\",\n    Private: \"private\",\n    Protected: \"protected\",\n};\n//# sourceMappingURL=Access.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Annotation = void 0;\nconst AstNode_1 = require(\"../core/AstNode\");\nclass Annotation extends AstNode_1.AstNode {\n    reference;\n    argument;\n    constructor(args) {\n        super();\n        this.reference = args.reference;\n        this.argument = args.argument;\n    }\n    write(writer) {\n        writer.addReference(this.reference);\n        writer.write(`${this.reference.name}(`);\n        if (this.argument != null) {\n            if (typeof this.argument === \"string\") {\n                writer.write(this.argument);\n            }\n            else {\n                this.argument.write(writer);\n            }\n        }\n        writer.write(\")\");\n    }\n}\nexports.Annotation = Annotation;\n//# sourceMappingURL=Annotation.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Class = void 0;\nconst Access_1 = require(\"./Access\");\nconst ClassReference_1 = require(\"./ClassReference\");\nconst AstNode_1 = require(\"../core/AstNode\");\nclass Class extends AstNode_1.AstNode {\n    name;\n    namespace;\n    access;\n    abstract;\n    static_;\n    sealed;\n    partial;\n    reference;\n    interfaceReferences;\n    isNestedClass;\n    annotations = [];\n    splitAnnotations;\n    fields = [];\n    constructors = [];\n    methods = [];\n    nestedClasses = [];\n    nestedInterfaces = [];\n    parentClassReference;\n    constructor({ name, namespace, access, abstract, static_, sealed, partial, parentClassReference, interfaceReferences, isNestedClass, annotations, splitAnnotations, }) {\n        super();\n        this.name = name;\n        this.namespace = namespace;\n        this.access = access;\n        this.abstract = abstract ?? false;\n        this.static_ = static_ ?? false;\n        this.sealed = sealed ?? false;\n        this.partial = partial ?? false;\n        this.isNestedClass = isNestedClass ?? false;\n        this.annotations = annotations ?? [];\n        this.splitAnnotations = splitAnnotations ?? true;\n        this.parentClassReference = parentClassReference;\n        this.interfaceReferences = interfaceReferences ?? [];\n        this.reference = new ClassReference_1.ClassReference({\n            name: this.name,\n            namespace: this.namespace,\n        });\n    }\n    addField(field) {\n        this.fields.push(field);\n    }\n    addConstructor(constructor) {\n        this.constructors.push(constructor);\n    }\n    addMethod(method) {\n        this.methods.push(method);\n    }\n    addNestedClass(subClass) {\n        this.nestedClasses.push(subClass);\n    }\n    addNestedInterface(subInterface) {\n        this.nestedInterfaces.push(subInterface);\n    }\n    write(writer) {\n        if (!this.isNestedClass) {\n            writer.writeLine(`namespace ${this.namespace};`);\n            writer.newLine();\n        }\n        if (this.annotations.length > 0) {\n            !this.splitAnnotations && writer.write(\"[\");\n            this.annotations.forEach((annotation, index) => {\n                if (this.splitAnnotations) {\n                    writer.write(\"[\");\n                    annotation.write(writer);\n                    writer.write(\"]\");\n                    writer.newLine();\n                }\n                else {\n                    annotation.write(writer);\n                    if (index < this.annotations.length - 1) {\n                        writer.write(\", \");\n                    }\n                }\n            });\n            !this.splitAnnotations && writer.write(\"]\");\n            writer.writeNewLineIfLastLineNot();\n        }\n        writer.write(`${this.access}`);\n        if ([this.abstract, this.sealed, this.static_].filter((x) => x).length > 1) {\n            throw new Error(\"A class can only be one of abstract, sealed, or static at a time\");\n        }\n        if (this.abstract) {\n            writer.write(\" abstract\");\n        }\n        if (this.sealed) {\n            writer.write(\" sealed\");\n        }\n        if (this.static_) {\n            writer.write(\" static\");\n        }\n        if (this.partial) {\n            writer.write(\" partial\");\n        }\n        writer.write(\" class\");\n        writer.write(` ${this.name}`);\n        if (this.parentClassReference != null ||\n            this.interfaceReferences.length > 0) {\n            writer.write(\" : \");\n            if (this.parentClassReference != null) {\n                this.parentClassReference.write(writer);\n                if (this.interfaceReferences.length > 0) {\n                    writer.write(\", \");\n                }\n            }\n            this.interfaceReferences.forEach((interfaceReference, index) => {\n                interfaceReference.write(writer);\n                // Don't write a comma after the last interface\n                if (index < this.interfaceReferences.length - 1) {\n                    writer.write(\", \");\n                }\n            });\n        }\n        writer.writeNewLineIfLastLineNot();\n        writer.writeLine(\"{\");\n        writer.indent();\n        this.writeFields({\n            writer,\n            fields: this.getFieldsByAccess(Access_1.Access.Private),\n        });\n        writer.dedent();\n        writer.indent();\n        this.writeFields({\n            writer,\n            fields: this.getFieldsByAccess(Access_1.Access.Protected),\n        });\n        writer.dedent();\n        writer.indent();\n        this.writeConstructors({ writer, constructors: this.constructors });\n        writer.dedent();\n        writer.indent();\n        this.writeFields({ writer, fields: this.getFieldsByAccess(Access_1.Access.Public) });\n        writer.dedent();\n        writer.indent();\n        this.nestedClasses.forEach((nestedClass, index) => {\n            nestedClass.write(writer);\n            writer.writeNewLineIfLastLineNot();\n            if (index < this.fields.length - 1) {\n                writer.newLine();\n            }\n        });\n        writer.dedent();\n        writer.indent();\n        this.nestedInterfaces.forEach((nestedInterface, index) => {\n            nestedInterface.write(writer);\n            writer.writeNewLineIfLastLineNot();\n            if (index < this.fields.length - 1) {\n                writer.newLine();\n            }\n        });\n        writer.dedent();\n        writer.indent();\n        this.writeMethods({\n            writer,\n            methods: this.getMethodsByAccess(Access_1.Access.Public),\n        });\n        writer.dedent();\n        writer.indent();\n        this.writeMethods({\n            writer,\n            methods: this.getMethodsByAccess(Access_1.Access.Private),\n        });\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n    writeConstructors({ writer, constructors, }) {\n        constructors.forEach((constructor, index) => {\n            writer.write(`${constructor.access} ${this.name} (`);\n            constructor.parameters.forEach((parameter, index) => {\n                parameter.write(writer);\n                if (index < constructor.parameters.length - 1) {\n                    writer.write(\", \");\n                }\n            });\n            writer.write(\")\");\n            if (constructor.bases && constructor.bases.length > 0) {\n                const bases = constructor.bases;\n                writer.write(\": base(\");\n                bases.forEach((base, index) => {\n                    writer.write(base);\n                    if (index < bases.length - 1) {\n                        writer.write(\", \");\n                    }\n                });\n                writer.write(\")\");\n            }\n            writer.writeLine(\" {\");\n            writer.indent();\n            constructor.body?.write(writer);\n            writer.dedent();\n            writer.writeLine(\"}\");\n            writer.newLine();\n        });\n    }\n    writeMethods({ writer, methods, }) {\n        methods.forEach((method, index) => {\n            method.write(writer);\n            writer.writeNewLineIfLastLineNot();\n            writer.newLine();\n        });\n    }\n    getMethodsByAccess(access) {\n        return this.methods.filter((method) => method.access === access);\n    }\n    writeFields({ writer, fields, }) {\n        fields.forEach((field, index) => {\n            field.write(writer);\n            writer.writeNewLineIfLastLineNot();\n            if (index < this.fields.length - 1) {\n                writer.newLine();\n            }\n        });\n    }\n    getFieldsByAccess(access) {\n        return this.fields.filter((field) => field.access === access);\n    }\n    getFields() {\n        return this.fields;\n    }\n    getMethods() {\n        return this.methods;\n    }\n}\nexports.Class = Class;\n//# sourceMappingURL=Class.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClassInstantiation = void 0;\nconst AstNode_1 = require(\"../core/AstNode\");\nclass ClassInstantiation extends AstNode_1.AstNode {\n    classReference;\n    arguments_;\n    constructor({ classReference, arguments_ }) {\n        super();\n        this.classReference = classReference;\n        this.arguments_ = arguments_;\n    }\n    write(writer) {\n        writer.write(`new ${this.classReference.name}(`);\n        writer.newLine();\n        writer.indent();\n        this.arguments_.forEach((argument, idx) => {\n            if (isNamedArgument(argument)) {\n                writer.write(`${argument.name}: `);\n                argument.assignment.write(writer);\n            }\n            else {\n                argument.write(writer);\n            }\n            if (idx < this.arguments_.length - 1) {\n                writer.write(\", \");\n            }\n        });\n        writer.dedent();\n        writer.writeLine(\");\");\n    }\n}\nexports.ClassInstantiation = ClassInstantiation;\nfunction isNamedArgument(argument) {\n    return argument?.name != null;\n}\n//# sourceMappingURL=ClassInstantiation.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StringEnumClassReference = exports.OneOfClassReference = exports.ClassReference = void 0;\nconst AstNode_1 = require(\"../core/AstNode\");\nclass ClassReference extends AstNode_1.AstNode {\n    name;\n    namespace;\n    constructor({ name, namespace }) {\n        super();\n        this.name = name;\n        this.namespace = namespace;\n    }\n    write(writer) {\n        writer.addReference(this);\n        writer.write(`${this.name}`);\n    }\n}\nexports.ClassReference = ClassReference;\nexports.OneOfClassReference = new ClassReference({\n    name: \"OneOf\",\n    namespace: \"OneOf\",\n});\n// TODO: remove this in favor of the one in PrebuiltUtilities\nexports.StringEnumClassReference = new ClassReference({\n    name: \"StringEnum\",\n    namespace: \"StringEnum\",\n});\n//# sourceMappingURL=ClassReference.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodeBlock = void 0;\nconst AstNode_1 = require(\"../core/AstNode\");\nclass CodeBlock extends AstNode_1.AstNode {\n    value;\n    references;\n    constructor(args) {\n        super();\n        this.value = args.code;\n        this.references = [];\n        if (args.references) {\n            this.references.push(...args.references);\n        }\n    }\n    write(writer) {\n        if (typeof this.value === \"string\") {\n            this.references.forEach((reference) => writer.addReference(reference));\n            writer.write(this.value);\n        }\n        else {\n            this.value(writer);\n        }\n    }\n}\nexports.CodeBlock = CodeBlock;\n//# sourceMappingURL=CodeBlock.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CoreClassReference = void 0;\nconst AstNode_1 = require(\"../core/AstNode\");\nclass CoreClassReference extends AstNode_1.AstNode {\n    name;\n    constructor({ name }) {\n        super();\n        this.name = name;\n    }\n    write(writer) {\n        writer.write(`${this.name}`);\n    }\n}\nexports.CoreClassReference = CoreClassReference;\n//# sourceMappingURL=CoreClassReference.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Dictionary = void 0;\nconst AstNode_1 = require(\"../core/AstNode\");\nclass Dictionary extends AstNode_1.AstNode {\n    keyType;\n    valueType;\n    entries;\n    constructor({ keyType, valueType, entries }) {\n        super();\n        this.keyType = keyType;\n        this.valueType = valueType;\n        this.entries = entries;\n    }\n    write(writer) {\n        writer.write(\"new Dictionary<\");\n        this.keyType.write(writer);\n        writer.write(\", \");\n        this.valueType.write(writer);\n        writer.write(\"> {\");\n        writer.newLine();\n        writer.indent();\n        for (const { key, value } of this.entries) {\n            writer.write(\"{ \");\n            key.write(writer);\n            writer.write(\", \");\n            value.write(writer);\n            writer.writeLine(\" }, \");\n        }\n        writer.dedent();\n        writer.write(\"}\");\n    }\n}\nexports.Dictionary = Dictionary;\n//# sourceMappingURL=Dictionary.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Enum = void 0;\nconst Annotation_1 = require(\"./Annotation\");\nconst ClassReference_1 = require(\"./ClassReference\");\nconst AstNode_1 = require(\"../core/AstNode\");\nconst System_1 = require(\"./dependencies/System\");\nclass Enum extends AstNode_1.AstNode {\n    name;\n    namespace;\n    access;\n    reference;\n    annotations;\n    fields = [];\n    constructor({ name, namespace, access, annotations }) {\n        super();\n        this.name = name;\n        this.namespace = namespace;\n        this.access = access;\n        this.annotations = annotations ?? [];\n        this.reference = new ClassReference_1.ClassReference({\n            name: this.name,\n            namespace: this.namespace,\n        });\n    }\n    addMember(field) {\n        this.fields.push({\n            name: field.name,\n            value: new Annotation_1.Annotation({\n                reference: System_1.ENUM_MEMBER,\n                argument: `Value = \"${field.value}\"`,\n            }),\n        });\n    }\n    write(writer) {\n        writer.writeLine(`namespace ${this.namespace};`);\n        writer.newLine();\n        if (this.annotations.length > 0) {\n            writer.write(\"[\");\n            for (const annotation of this.annotations) {\n                annotation.write(writer);\n            }\n            writer.writeLine(\"]\");\n        }\n        writer.write(`${this.access} `);\n        writer.write(\"enum \");\n        writer.writeLine(`${this.name}`);\n        writer.writeLine(\"{\");\n        writer.indent();\n        this.fields.forEach((field, index) => {\n            writer.write(\"[\");\n            field.value.write(writer);\n            writer.writeLine(\"]\");\n            writer.write(field.name);\n            if (index < this.fields.length - 1) {\n                writer.writeLine(\",\");\n                writer.newLine();\n            }\n        });\n        writer.writeNewLineIfLastLineNot();\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n}\nexports.Enum = Enum;\n//# sourceMappingURL=Enum.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Field = void 0;\nconst Annotation_1 = require(\"./Annotation\");\nconst ClassReference_1 = require(\"./ClassReference\");\nconst AstNode_1 = require(\"../core/AstNode\");\nclass Field extends AstNode_1.AstNode {\n    name;\n    access;\n    readonly_;\n    type;\n    get;\n    init;\n    set;\n    annotations;\n    initializer;\n    summary;\n    jsonPropertyName;\n    splitAnnotations;\n    constructor({ name, type, get, init, set, access, readonly_, annotations, initializer, summary, jsonPropertyName, splitAnnotations, }) {\n        super();\n        this.name = name;\n        this.type = type;\n        this.get = get ?? false;\n        this.init = init ?? false;\n        this.set = set ?? false;\n        this.access = access;\n        this.readonly_ = readonly_ ?? false;\n        this.annotations = annotations ?? [];\n        this.initializer = initializer;\n        this.summary = summary;\n        this.jsonPropertyName = jsonPropertyName;\n        this.splitAnnotations = splitAnnotations ?? true;\n        if (this.jsonPropertyName != null) {\n            this.annotations = [\n                new Annotation_1.Annotation({\n                    reference: new ClassReference_1.ClassReference({\n                        name: \"JsonPropertyName\",\n                        namespace: \"System.Text.Json.Serialization\",\n                    }),\n                    argument: `\"${this.jsonPropertyName}\"`,\n                }),\n                ...this.annotations,\n            ];\n        }\n    }\n    write(writer) {\n        if (this.summary != null) {\n            writer.writeLine(\"/// <summary>\");\n            this.summary.split(\"\\n\").forEach((line) => {\n                writer.writeLine(`/// ${line}`);\n            });\n            writer.writeLine(\"/// </summary>\");\n        }\n        if (this.annotations.length > 0) {\n            !this.splitAnnotations && writer.write(\"[\");\n            this.annotations.forEach((annotation, index) => {\n                if (this.splitAnnotations) {\n                    writer.write(\"[\");\n                    annotation.write(writer);\n                    writer.write(\"]\");\n                    writer.newLine();\n                }\n                else {\n                    annotation.write(writer);\n                    if (index < (this.annotations ? this.annotations.length : 0) - 1) {\n                        writer.write(\", \");\n                    }\n                }\n            });\n        }\n        writer.write(`${this.access} `);\n        writer.write(this.readonly_ ? \"readonly \" : \"\");\n        writer.writeNode(this.type);\n        writer.write(` ${this.name}`);\n        if (this.get || this.init || this.set) {\n            writer.write(\" { \");\n            if (this.get) {\n                writer.write(\"get; \");\n            }\n            if (this.init) {\n                writer.write(\"init; \");\n            }\n            if (this.set) {\n                writer.write(\"set; \");\n            }\n            writer.write(\"}\");\n        }\n        if (this.initializer != null) {\n            writer.write(\" = \");\n            this.initializer.write(writer);\n            writer.writeLine(\";\");\n        }\n        else if (!this.get && !this.init && !this.set) {\n            writer.writeLine(\";\");\n        }\n    }\n}\nexports.Field = Field;\n//# sourceMappingURL=Field.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GenericClassReference = void 0;\nconst AstNode_1 = require(\"../core/AstNode\");\nclass GenericClassReference extends AstNode_1.AstNode {\n    reference;\n    innerType;\n    constructor(args) {\n        super();\n        this.reference = args.reference;\n        this.innerType = args.innerType;\n    }\n    write(writer) {\n        writer.addReference(this.reference);\n        writer.write(`${this.reference.name}<`);\n        this.innerType.write(writer);\n        writer.write(\">\");\n    }\n}\nexports.GenericClassReference = GenericClassReference;\n//# sourceMappingURL=GenericClassReference.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Interface = void 0;\nconst ClassReference_1 = require(\"./ClassReference\");\nconst AstNode_1 = require(\"../core/AstNode\");\nconst Method_1 = require(\"./Method\");\nclass Interface extends AstNode_1.AstNode {\n    name;\n    namespace;\n    access;\n    partial;\n    reference;\n    isNestedInterface;\n    fields = [];\n    methods = [];\n    constructor({ name, namespace, access, partial, isNestedInterface, }) {\n        super();\n        this.name = name;\n        this.namespace = namespace;\n        this.access = access;\n        this.partial = partial ?? false;\n        this.isNestedInterface = isNestedInterface ?? false;\n        this.reference = new ClassReference_1.ClassReference({\n            name: this.name,\n            namespace: this.namespace,\n        });\n    }\n    addField(field) {\n        this.fields.push(field);\n    }\n    addMethod(method) {\n        method.classType = Method_1.MethodClassType.INTERFACE;\n        this.methods.push(method);\n    }\n    write(writer) {\n        if (!this.isNestedInterface) {\n            writer.writeLine(`namespace ${this.namespace};`);\n            writer.newLine();\n        }\n        writer.write(`${this.access} `);\n        if (this.partial) {\n            writer.write(\"partial \");\n        }\n        writer.write(\"interface \");\n        writer.writeLine(`${this.name}`);\n        writer.writeLine(\"{\");\n        writer.indent();\n        for (const field of this.fields) {\n            field.write(writer);\n            writer.writeLine(\"\");\n        }\n        writer.dedent();\n        writer.indent();\n        for (const method of this.methods) {\n            method.write(writer);\n            writer.writeLine(\"\");\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n    getMethods() {\n        return this.methods;\n    }\n}\nexports.Interface = Interface;\n//# sourceMappingURL=Interface.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Method = exports.MethodClassType = exports.MethodType = void 0;\nconst AstNode_1 = require(\"../core/AstNode\");\nconst MethodInvocation_1 = require(\"./MethodInvocation\");\nvar MethodType;\n(function (MethodType) {\n    MethodType[MethodType[\"INSTANCE\"] = 0] = \"INSTANCE\";\n    MethodType[MethodType[\"STATIC\"] = 1] = \"STATIC\";\n})(MethodType || (exports.MethodType = MethodType = {}));\nvar MethodClassType;\n(function (MethodClassType) {\n    MethodClassType[MethodClassType[\"CLASS\"] = 0] = \"CLASS\";\n    MethodClassType[MethodClassType[\"INTERFACE\"] = 1] = \"INTERFACE\";\n})(MethodClassType || (exports.MethodClassType = MethodClassType = {}));\nclass Method extends AstNode_1.AstNode {\n    name;\n    isAsync;\n    access;\n    return;\n    body;\n    summary;\n    type;\n    reference;\n    classType = MethodClassType.CLASS;\n    parameters;\n    extensionParameter;\n    annotations;\n    splitAnnotations;\n    constructor({ name, isAsync, access, return_, body, summary, type, classReference, parameters, extensionParameter, annotations, splitAnnotations, }) {\n        super();\n        this.name = name;\n        this.isAsync = isAsync;\n        this.access = access;\n        this.return = return_;\n        this.body = body;\n        this.summary = summary;\n        this.type = type ?? MethodType.INSTANCE;\n        this.reference = classReference;\n        this.parameters = parameters;\n        this.extensionParameter = extensionParameter;\n        this.annotations = annotations ?? [];\n        this.splitAnnotations = splitAnnotations ?? true;\n    }\n    addParameter(parameter) {\n        this.parameters.push(parameter);\n    }\n    write(writer) {\n        if (this.summary != null) {\n            writer.writeLine(\"/// <summary>\");\n            this.summary.split(\"\\n\").forEach((line) => {\n                writer.writeLine(`/// ${line}`);\n            });\n            writer.writeLine(\"/// </summary>\");\n        }\n        if (this.annotations && this.annotations.length > 0) {\n            !this.splitAnnotations && writer.write(\"[\");\n            this.annotations.forEach((annotation, index) => {\n                if (this.splitAnnotations) {\n                    writer.write(\"[\");\n                    annotation.write(writer);\n                    writer.write(\"]\");\n                    writer.newLine();\n                }\n                else {\n                    annotation.write(writer);\n                    if (index < (this.annotations ? this.annotations.length : 0) - 1) {\n                        writer.write(\", \");\n                    }\n                }\n            });\n            !this.splitAnnotations && writer.write(\"]\");\n            writer.writeNewLineIfLastLineNot();\n        }\n        writer.write(`${this.access} `);\n        if (this.type === MethodType.STATIC) {\n            writer.write(\"static \");\n        }\n        if (this.isAsync && this.classType !== MethodClassType.INTERFACE) {\n            writer.write(\"async \");\n        }\n        if (this.return == null) {\n            const voidReturn = this.isAsync ? \"Task\" : \"void\";\n            writer.write(voidReturn);\n            writer.write(\" \");\n        }\n        else {\n            if (!this.isAsync) {\n                this.return.write(writer);\n            }\n            else {\n                writer.write(\"Task<\");\n                this.return.write(writer);\n                writer.write(\">\");\n            }\n            writer.write(\" \");\n        }\n        writer.write(`${this.name}(`);\n        if (this.extensionParameter) {\n            writer.write(\"this \");\n            this.extensionParameter.write(writer);\n            this.parameters?.length > 0 && writer.write(\", \");\n        }\n        this.parameters.forEach((parameter, idx) => {\n            parameter.write(writer);\n            if (idx < this.parameters.length - 1) {\n                writer.write(\", \");\n            }\n        });\n        writer.write(\")\");\n        if (this.classType === MethodClassType.INTERFACE) {\n            writer.write(\";\");\n        }\n        else {\n            writer.writeLine(\" {\");\n            writer.indent();\n            this.body?.write(writer);\n            writer.dedent();\n            writer.writeLine(\"}\");\n        }\n    }\n    getParameters() {\n        return this.parameters;\n    }\n    getInvocation(args, on) {\n        return new MethodInvocation_1.MethodInvocation({\n            method: this,\n            arguments_: args,\n            on,\n        });\n    }\n    getInvocationFromExample(example, on) {\n        const args = new Map();\n        for (const parameter of this.parameters) {\n            const value = example.get(parameter.name);\n            if (value !== undefined) {\n                // TODO: actually handle these examples\n                // args.set(parameter, new CodeBlock({ value: value as string }));\n            }\n        }\n        return new MethodInvocation_1.MethodInvocation({\n            method: this,\n            arguments_: args,\n            on,\n        });\n    }\n}\nexports.Method = Method;\n//# sourceMappingURL=Method.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MethodInvocation = void 0;\nconst AstNode_1 = require(\"../core/AstNode\");\nclass MethodInvocation extends AstNode_1.AstNode {\n    arguments;\n    method;\n    on;\n    constructor({ method, arguments_, on }) {\n        super();\n        this.method = method;\n        this.arguments = arguments_;\n        this.on = on;\n    }\n    write(writer) {\n        if (this.method.isAsync) {\n            writer.write(\"await \");\n        }\n        if (this.on) {\n            this.on.write(writer);\n            writer.write(\".\");\n        }\n        writer.write(`${this.method.name}(`);\n        writer.indent();\n        [...this.arguments.entries()].forEach(([parameter, assignment], idx) => {\n            parameter.write(writer);\n            assignment.write(writer);\n            if (idx < this.arguments.size - 1) {\n                writer.write(\", \");\n            }\n        });\n        writer.dedent();\n        writer.write(\")\");\n    }\n}\nexports.MethodInvocation = MethodInvocation;\n//# sourceMappingURL=MethodInvocation.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parameter = void 0;\nconst AstNode_1 = require(\"../core/AstNode\");\nclass Parameter extends AstNode_1.AstNode {\n    name;\n    docs;\n    initializer;\n    annotations;\n    splitAnnotations;\n    type;\n    constructor({ name, type, docs, initializer, annotations, splitAnnotations, }) {\n        super();\n        this.name = name;\n        this.type = type;\n        this.docs = docs;\n        this.annotations = annotations ?? [];\n        this.splitAnnotations = splitAnnotations ?? true;\n    }\n    write(writer) {\n        if (this.annotations && this.annotations.length > 0) {\n            !this.splitAnnotations && writer.write(\"[\");\n            this.annotations.forEach((annotation, index) => {\n                if (this.splitAnnotations) {\n                    writer.write(\"[\");\n                    annotation.write(writer);\n                    writer.write(\"]\");\n                    writer.newLine();\n                }\n                else {\n                    annotation.write(writer);\n                    if (index < (this.annotations ? this.annotations.length : 0) - 1) {\n                        writer.write(\", \");\n                    }\n                }\n            });\n            !this.splitAnnotations && writer.write(\"]\");\n            writer.writeNewLineIfLastLineNot();\n        }\n        this.type.write(writer);\n        writer.write(` ${this.name}`);\n        if (this.initializer != null) {\n            writer.write(` = ${this.initializer}`);\n        }\n    }\n}\nexports.Parameter = Parameter;\n//# sourceMappingURL=Parameter.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProgramClass = void 0;\nconst AstNode_1 = require(\"../core/AstNode\");\nclass ProgramClass extends AstNode_1.AstNode {\n    references;\n    startFileBlocks;\n    builderServicesBlocks;\n    appBlocks;\n    catchBlocks;\n    finallyBlocks;\n    endFileBlocks;\n    constructor(args) {\n        super();\n        this.startFileBlocks = args.startFileBlocks ?? [];\n        this.builderServicesBlocks = args.builderServicesBlocks;\n        this.appBlocks = args.appBlocks;\n        this.catchBlocks = args.catchBlocks ?? [];\n        this.finallyBlocks = args.finallyBlocks ?? [];\n        this.endFileBlocks = args.endFileBlocks ?? [];\n        this.references = args.references;\n    }\n    addReference(reference) {\n        this.references.push(reference);\n    }\n    write(writer) {\n        this.references.forEach((reference) => writer.addReference(reference));\n        const hasTryCatch = this.catchBlocks.length > 0 || this.finallyBlocks.length > 0;\n        if (this.startFileBlocks.length > 0) {\n            this.startFileBlocks.forEach((block) => block.write(writer));\n            writer.writeLine();\n        }\n        if (hasTryCatch) {\n            writer.writeLine(\"try\");\n            writer.writeLine(\"{\");\n            writer.indent();\n        }\n        if (this.builderServicesBlocks.length > 0) {\n            this.builderServicesBlocks.forEach((block) => block.write(writer));\n            writer.writeLine();\n        }\n        if (this.appBlocks.length > 0) {\n            this.appBlocks.forEach((block) => block.write(writer));\n            writer.writeLine();\n        }\n        if (hasTryCatch) {\n            writer.dedent();\n            writer.writeLine(\"}\");\n            if (this.catchBlocks.length > 0) {\n                writer.writeLine(\"catch(Exception ex)\");\n                writer.writeLine(\"{\");\n                writer.indent();\n                this.catchBlocks.forEach((block) => block.write(writer));\n                writer.dedent();\n                writer.writeLine();\n                writer.writeLine(\"}\");\n            }\n            if (this.finallyBlocks.length > 0) {\n                writer.writeLine(\"finally\");\n                writer.writeLine(\"{\");\n                writer.indent();\n                this.finallyBlocks.forEach((block) => block.write(writer));\n                writer.dedent();\n                writer.writeLine();\n                writer.writeLine(\"}\");\n            }\n        }\n        if (this.endFileBlocks.length > 0) {\n            this.endFileBlocks.forEach((block) => block.write(writer));\n        }\n        writer.writeLine();\n    }\n}\nexports.ProgramClass = ProgramClass;\n//# sourceMappingURL=ProgramClass.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Type = void 0;\nconst assertNever_1 = require(\"../utils/assertNever\");\nconst ClassReference_1 = require(\"./ClassReference\");\nconst AstNode_1 = require(\"../core/AstNode\");\n/* A C# parameter to a method */\nclass Type extends AstNode_1.AstNode {\n    internalType;\n    constructor(internalType) {\n        super();\n        this.internalType = internalType;\n    }\n    write(writer) {\n        switch (this.internalType.type) {\n            case \"integer\":\n                writer.write(\"int\");\n                break;\n            case \"long\":\n                writer.write(\"long\");\n                break;\n            case \"string\":\n                writer.write(\"string\");\n                break;\n            case \"boolean\":\n                writer.write(\"bool\");\n                break;\n            case \"double\":\n                writer.write(\"double\");\n                break;\n            case \"date\":\n                writer.write(\"DateOnly\");\n                break;\n            case \"dateTime\":\n                writer.write(\"DateTime\");\n                break;\n            case \"uuid\":\n                writer.write(\"Guid\");\n                break;\n            case \"object\":\n                writer.write(\"object\");\n                break;\n            case \"list\":\n                writer.write(\"List<\");\n                this.internalType.value.write(writer);\n                writer.write(\">\");\n                break;\n            case \"set\":\n                writer.write(\"HashSet<\");\n                this.internalType.value.write(writer);\n                writer.write(\">\");\n                break;\n            case \"map\":\n                writer.write(\"Dictionary<\");\n                this.internalType.keyType.write(writer);\n                writer.write(\", \");\n                this.internalType.valueType.write(writer);\n                writer.write(\">\");\n                break;\n            case \"optional\":\n                this.internalType.value.write(writer);\n                writer.write(\"?\");\n                break;\n            case \"reference\":\n                writer.addReference(this.internalType.value);\n                writer.write(this.internalType.value.name);\n                break;\n            case \"coreReference\":\n                writer.write(this.internalType.value.name);\n                break;\n            case \"genericReference\":\n                this.internalType.value.write(writer);\n                break;\n            case \"oneOf\":\n                writer.addReference(ClassReference_1.OneOfClassReference);\n                writer.write(\"OneOf<\");\n                this.internalType.memberValues.forEach((value, index) => {\n                    if (index !== 0) {\n                        writer.write(\", \");\n                    }\n                    value.write(writer);\n                });\n                writer.write(\">\");\n                break;\n            case \"stringEnum\":\n                writer.addReference(ClassReference_1.StringEnumClassReference);\n                writer.write(\"StringEnum<\");\n                this.internalType.value.write(writer);\n                writer.write(\">\");\n                break;\n            default:\n                (0, assertNever_1.assertNever)(this.internalType);\n        }\n    }\n    /* Static factory methods for creating a Type */\n    static string() {\n        return new this({\n            type: \"string\",\n        });\n    }\n    static boolean() {\n        return new this({\n            type: \"boolean\",\n        });\n    }\n    static integer() {\n        return new this({\n            type: \"integer\",\n        });\n    }\n    static long() {\n        return new this({\n            type: \"long\",\n        });\n    }\n    static double() {\n        return new this({\n            type: \"double\",\n        });\n    }\n    static date() {\n        return new this({\n            type: \"date\",\n        });\n    }\n    static dateTime() {\n        return new this({\n            type: \"dateTime\",\n        });\n    }\n    static uuid() {\n        return new this({\n            type: \"uuid\",\n        });\n    }\n    static object() {\n        return new this({\n            type: \"object\",\n        });\n    }\n    static list(value) {\n        return new this({\n            type: \"list\",\n            value,\n        });\n    }\n    static set(value) {\n        return new this({\n            type: \"set\",\n            value,\n        });\n    }\n    static map(keyType, valueType) {\n        return new this({\n            type: \"map\",\n            keyType,\n            valueType,\n        });\n    }\n    static optional(value) {\n        return new this({\n            type: \"optional\",\n            value,\n        });\n    }\n    static reference(value) {\n        return new this({\n            type: \"reference\",\n            value,\n        });\n    }\n    static genericReference(value) {\n        return new this({\n            type: \"genericReference\",\n            value,\n        });\n    }\n    static coreClass(value) {\n        return new this({\n            type: \"coreReference\",\n            value,\n        });\n    }\n    static oneOf(memberValues) {\n        return new this({\n            type: \"oneOf\",\n            memberValues,\n        });\n    }\n    static stringEnum(value) {\n        return new this({\n            type: \"stringEnum\",\n            value,\n        });\n    }\n}\nexports.Type = Type;\n//# sourceMappingURL=Type.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TestFixture = void 0;\nconst __1 = require(\"../\");\nconst NUNIT_FRAMEWORK_NAMESPACE = \"NUnit.Framework\";\nexports.TestFixture = new __1.ClassReference({\n    name: \"TestFixture\",\n    namespace: NUNIT_FRAMEWORK_NAMESPACE,\n});\n//# sourceMappingURL=NUnit.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ENUM_MEMBER = void 0;\nconst __1 = require(\"../\");\nexports.ENUM_MEMBER = new __1.ClassReference({\n    namespace: \"System.Runtime.Serialization\",\n    name: \"EnumMember\",\n});\n//# sourceMappingURL=System.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.system = exports.nunit = void 0;\nconst tslib_1 = require(\"tslib\");\nexports.nunit = tslib_1.__importStar(require(\"./NUnit\"));\nexports.system = tslib_1.__importStar(require(\"./System\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProgramClass = exports.Dictionary = exports.CoreClassReference = exports.MethodInvocation = exports.ClassInstantiation = exports.Interface = exports.Type = exports.Parameter = exports.MethodType = exports.Method = exports.Field = exports.Enum = exports.dependencies = exports.CodeBlock = exports.GenericClassReference = exports.ClassReference = exports.Class = exports.Annotation = void 0;\nconst tslib_1 = require(\"tslib\");\nvar Annotation_1 = require(\"./Annotation\");\nObject.defineProperty(exports, \"Annotation\", { enumerable: true, get: function () { return Annotation_1.Annotation; } });\nvar Class_1 = require(\"./Class\");\nObject.defineProperty(exports, \"Class\", { enumerable: true, get: function () { return Class_1.Class; } });\nvar ClassReference_1 = require(\"./ClassReference\");\nObject.defineProperty(exports, \"ClassReference\", { enumerable: true, get: function () { return ClassReference_1.ClassReference; } });\nvar GenericClassReference_1 = require(\"./GenericClassReference\");\nObject.defineProperty(exports, \"GenericClassReference\", { enumerable: true, get: function () { return GenericClassReference_1.GenericClassReference; } });\nvar CodeBlock_1 = require(\"./CodeBlock\");\nObject.defineProperty(exports, \"CodeBlock\", { enumerable: true, get: function () { return CodeBlock_1.CodeBlock; } });\nexports.dependencies = tslib_1.__importStar(require(\"./dependencies\"));\nvar Enum_1 = require(\"./Enum\");\nObject.defineProperty(exports, \"Enum\", { enumerable: true, get: function () { return Enum_1.Enum; } });\nvar Field_1 = require(\"./Field\");\nObject.defineProperty(exports, \"Field\", { enumerable: true, get: function () { return Field_1.Field; } });\nvar Method_1 = require(\"./Method\");\nObject.defineProperty(exports, \"Method\", { enumerable: true, get: function () { return Method_1.Method; } });\nObject.defineProperty(exports, \"MethodType\", { enumerable: true, get: function () { return Method_1.MethodType; } });\nvar Parameter_1 = require(\"./Parameter\");\nObject.defineProperty(exports, \"Parameter\", { enumerable: true, get: function () { return Parameter_1.Parameter; } });\nvar Type_1 = require(\"./Type\");\nObject.defineProperty(exports, \"Type\", { enumerable: true, get: function () { return Type_1.Type; } });\nvar Interface_1 = require(\"./Interface\");\nObject.defineProperty(exports, \"Interface\", { enumerable: true, get: function () { return Interface_1.Interface; } });\nvar ClassInstantiation_1 = require(\"./ClassInstantiation\");\nObject.defineProperty(exports, \"ClassInstantiation\", { enumerable: true, get: function () { return ClassInstantiation_1.ClassInstantiation; } });\nvar MethodInvocation_1 = require(\"./MethodInvocation\");\nObject.defineProperty(exports, \"MethodInvocation\", { enumerable: true, get: function () { return MethodInvocation_1.MethodInvocation; } });\nvar CoreClassReference_1 = require(\"./CoreClassReference\");\nObject.defineProperty(exports, \"CoreClassReference\", { enumerable: true, get: function () { return CoreClassReference_1.CoreClassReference; } });\nvar Dictionary_1 = require(\"./Dictionary\");\nObject.defineProperty(exports, \"Dictionary\", { enumerable: true, get: function () { return Dictionary_1.Dictionary; } });\nvar ProgramClass_1 = require(\"./ProgramClass\");\nObject.defineProperty(exports, \"ProgramClass\", { enumerable: true, get: function () { return ProgramClass_1.ProgramClass; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AstNode = void 0;\nconst Writer_1 = require(\"./Writer\");\nclass AstNode {\n    /**\n     * Writes the node to a string.\n     */\n    toString() {\n        const writer = new Writer_1.Writer({});\n        this.write(writer);\n        return writer.toString();\n    }\n}\nexports.AstNode = AstNode;\n//# sourceMappingURL=AstNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Writer = void 0;\nconst TAB_SIZE = 4;\nclass Writer {\n    /* The contents being written */\n    buffer = \"\";\n    /* Indentation level (multiple of 4) */\n    indentLevel = 0;\n    /* Whether anything has been written to the buffer */\n    hasWrittenAnything = false;\n    /* Whether the last character written was a newline */\n    lastCharacterIsNewline = false;\n    /* The current line number */\n    references = {};\n    /* The namespace that is being written to */\n    namespace;\n    constructor({ namespace }) {\n        this.namespace = namespace;\n    }\n    write(text) {\n        const textEndsInNewline = text.length > 0 && text.endsWith(\"\\n\");\n        // temporarily remove the trailing newline, since we don't want to add the indent prefix after it\n        const textWithoutNewline = textEndsInNewline\n            ? text.substring(0, text.length - 1)\n            : text;\n        const indent = this.getIndentString();\n        let indentedText = textWithoutNewline.replace(\"\\n\", `\\n${indent}`);\n        if (this.isAtStartOfLine()) {\n            indentedText = indent + indentedText;\n        }\n        if (textEndsInNewline) {\n            indentedText += \"\\n\";\n        }\n        this.writeInternal(indentedText);\n    }\n    writeNode(node) {\n        node.write(this);\n    }\n    /* Only writes a newline if last line in the buffer is not a newline */\n    writeLine(text = \"\") {\n        this.write(text);\n        this.writeNewLineIfLastLineNot();\n    }\n    /* Always writes newline */\n    newLine() {\n        this.writeInternal(\"\\n\");\n    }\n    writeNewLineIfLastLineNot() {\n        if (!this.lastCharacterIsNewline) {\n            this.writeInternal(\"\\n\");\n        }\n    }\n    indent() {\n        this.indentLevel++;\n    }\n    dedent() {\n        this.indentLevel--;\n    }\n    addReference(reference) {\n        if (reference.namespace == null) {\n            return;\n        }\n        const namespace = this.references[reference.namespace];\n        if (namespace != null) {\n            namespace.push(reference);\n        }\n        else {\n            this.references[reference.namespace] = [reference];\n        }\n    }\n    toString() {\n        const imports = this.stringifyImports();\n        if (imports.length > 0) {\n            return `${imports}\\n\\n${this.buffer}`;\n        }\n        return this.buffer;\n    }\n    /*******************************\n     * Helper Methods\n     *******************************/\n    writeInternal(text) {\n        if (text.length > 0) {\n            this.hasWrittenAnything = true;\n            this.lastCharacterIsNewline = text.endsWith(\"\\n\");\n        }\n        return (this.buffer += text);\n    }\n    isAtStartOfLine() {\n        return this.lastCharacterIsNewline || !this.hasWrittenAnything;\n    }\n    getIndentString() {\n        return \" \".repeat(this.indentLevel * TAB_SIZE);\n    }\n    stringifyImports() {\n        return (Object.keys(this.references)\n            // filter out the current namespace\n            .filter((referenceNamespace) => referenceNamespace !== this.namespace)\n            .map((ref) => `using ${ref};`)\n            .join(\"\\n\"));\n    }\n}\nexports.Writer = Writer;\n//# sourceMappingURL=Writer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Writer = exports.AstNode = void 0;\nvar AstNode_1 = require(\"./AstNode\");\nObject.defineProperty(exports, \"AstNode\", { enumerable: true, get: function () { return AstNode_1.AstNode; } });\nvar Writer_1 = require(\"./Writer\");\nObject.defineProperty(exports, \"Writer\", { enumerable: true, get: function () { return Writer_1.Writer; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertNeverNoThrow = exports.assertNever = void 0;\nfunction assertNever(x) {\n    throw new Error(\"Unexpected value: \" + JSON.stringify(x));\n}\nexports.assertNever = assertNever;\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction assertNeverNoThrow(_) { }\nexports.assertNeverNoThrow = assertNeverNoThrow;\n//# sourceMappingURL=assertNever.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Types = exports.programClass = exports.dictionary = exports.enum_ = exports.interface_ = exports.parameter = exports.method = exports.field = exports.codeblock = exports.coreClassReference = exports.invokeMethod = exports.instantiateClass = exports.genericClassReference = exports.classReference = exports.annotation = exports.class_ = void 0;\nconst ast_1 = require(\"../ast\");\nconst GenericClassReference_1 = require(\"../ast/GenericClassReference\");\nfunction class_(args) {\n    return new ast_1.Class(args);\n}\nexports.class_ = class_;\nfunction annotation(args) {\n    return new ast_1.Annotation(args);\n}\nexports.annotation = annotation;\nfunction classReference(args) {\n    return new ast_1.ClassReference(args);\n}\nexports.classReference = classReference;\nfunction genericClassReference(args) {\n    return new GenericClassReference_1.GenericClassReference(args);\n}\nexports.genericClassReference = genericClassReference;\nfunction instantiateClass(args) {\n    return new ast_1.ClassInstantiation(args);\n}\nexports.instantiateClass = instantiateClass;\nfunction invokeMethod(args) {\n    return new ast_1.MethodInvocation(args);\n}\nexports.invokeMethod = invokeMethod;\nfunction coreClassReference(args) {\n    return new ast_1.CoreClassReference(args);\n}\nexports.coreClassReference = coreClassReference;\nfunction codeblock(args) {\n    return new ast_1.CodeBlock(args);\n}\nexports.codeblock = codeblock;\nfunction field(args) {\n    return new ast_1.Field(args);\n}\nexports.field = field;\nfunction method(args) {\n    return new ast_1.Method(args);\n}\nexports.method = method;\nfunction parameter(args) {\n    return new ast_1.Parameter(args);\n}\nexports.parameter = parameter;\nfunction interface_(args) {\n    return new ast_1.Interface(args);\n}\nexports.interface_ = interface_;\nfunction enum_(args) {\n    return new ast_1.Enum(args);\n}\nexports.enum_ = enum_;\nfunction dictionary(args) {\n    return new ast_1.Dictionary(args);\n}\nexports.dictionary = dictionary;\nfunction programClass(args) {\n    return new ast_1.ProgramClass(args);\n}\nexports.programClass = programClass;\nexports.Types = ast_1.Type;\n//# sourceMappingURL=csharp-support.js.map","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {\n  dotnetPluginEventsTypes,\n  dotnetPluginEventsParams as dotnet,\n  dotnetTypes,\n  EnumEntityAction,\n  EnumModuleActionType,\n  FileMap,\n} from \"@amplication/code-gen-types\";\nimport {\n  Class,\n  CodeBlock,\n  CsharpSupport,\n  MethodType,\n  ProgramClass,\n} from \"@amplication/csharp-ast\";\nimport { pascalCase } from \"pascal-case\";\nimport {\n  CreateSeedDevelopmentDataBody,\n  createAppServices,\n  createBuildersServices,\n  createMethodAuthorizeAnnotation,\n  createRelatedMethodAuthorizeAnnotation,\n  createStaticFileFileMap,\n  getEntityRoleMap,\n} from \"./core\";\nimport { resolve, join } from \"path\";\n\nclass AuthCorePlugin implements dotnetTypes.AmplicationPlugin {\n  register(): dotnetPluginEventsTypes.DotnetEvents {\n    return {\n      CreateEntityControllerBase: {\n        after: this.afterCreateControllerBase,\n      },\n      CreateControllerBaseModuleFile: {\n        after: this.afterCreateControllerBaseModule,\n      },\n      CreateResourceDbContextFile: {\n        after: this.afterCreateResourceDbContextFile,\n      },\n      LoadStaticFiles: {\n        after: this.afterLoadStaticFiles,\n      },\n      CreateProgramFile: {\n        after: this.afterCreateProgramFile,\n      },\n      CreateSeedDevelopmentDataFile: {\n        after: this.afterCreateSeedDevelopmentDataFile,\n      },\n      CreateServerCsproj: {\n        before: this.beforeCreateServerCsproj,\n      },\n    };\n  }\n\n  async beforeCreateServerCsproj(\n    context: dotnetTypes.DsgContext,\n    eventParams: dotnet.CreateServerCsprojParams\n  ): Promise<dotnet.CreateServerCsprojParams> {\n    const { packageReferences } = eventParams;\n\n    packageReferences.push({\n      include: \"Microsoft.AspNetCore.Identity.EntityFrameworkCore\",\n      version: \"8.0.4\",\n    });\n\n    packageReferences.push({\n      include: \"Swashbuckle.AspNetCore.Filters\",\n      version: \"8.0.1\",\n    });\n    return eventParams;\n  }\n\n  afterCreateProgramFile(\n    { resourceInfo, serverDirectories }: dotnetTypes.DsgContext,\n    eventParams: dotnet.CreateProgramFileParams,\n    programClassMap: FileMap<ProgramClass>\n  ): FileMap<ProgramClass> {\n    if (!resourceInfo) return programClassMap;\n    const serviceNamespace = pascalCase(resourceInfo.name);\n    const programCsPath = join(serverDirectories.srcDirectory, \"Program.cs\");\n    const programClass = programClassMap.get(programCsPath);\n    if (!programClass) \n      return programClassMap;\n \n    createBuildersServices(serviceNamespace, programClass.code);\n    createAppServices( programClass.code);\n\n    return programClassMap;\n  }\n\n  async afterLoadStaticFiles(\n    context: dotnetTypes.DsgContext,\n    eventParams: dotnet.LoadStaticFilesParams,\n    files: FileMap<CodeBlock>\n  ): Promise<FileMap<CodeBlock>> {\n    const { resourceInfo } = context;\n    if (!resourceInfo) return files;\n\n    const resourceName = pascalCase(resourceInfo.name);\n\n    const destPath = `${eventParams.basePath}/src/APIs/Common/Auth/ProgramAuthExtensions.cs`;\n    const filePath = resolve(\n      __dirname,\n      \"./static/common/auth/ProgramAuthExtensions.cs\"\n    );\n\n    const programAuthExtensionsFileMap = await createStaticFileFileMap(\n      destPath,\n      filePath,\n      context,\n      [\n        CsharpSupport.classReference({\n          name: `${resourceName}DbContext`,\n          namespace: `${resourceName}.Infrastructure`,\n        }),\n      ]\n    );\n\n    const rolesManagerDestPath = `${eventParams.basePath}/src/Infrastructure/RolesManager.cs`;\n    const rolesManagerFilePath = resolve(\n      __dirname,\n      \"./static/infrastructure/RolesManager.cs\"\n    );\n\n    const rolesManagerFileMap = await createStaticFileFileMap(\n      rolesManagerDestPath,\n      rolesManagerFilePath,\n      context\n    );\n\n    files.mergeMany([programAuthExtensionsFileMap, rolesManagerFileMap]);\n\n    return files;\n  }\n\n  afterCreateResourceDbContextFile(\n    context: dotnetTypes.DsgContext,\n    eventParams: dotnet.CreateResourceDbContextFileParams,\n    files: FileMap<Class>\n  ): FileMap<Class> {\n    const { resourceDbContextPath, resourceName } = eventParams;\n\n    const modelFile = files.get(\n      `${resourceDbContextPath}${resourceName}DbContext.cs`\n    );\n\n    if (!modelFile) return files;\n\n    modelFile.code.parentClassReference = CsharpSupport.genericClassReference({\n      reference: CsharpSupport.classReference({\n        name: `IdentityDbContext`,\n        namespace: \"Microsoft.AspNetCore.Identity.EntityFrameworkCore\",\n      }),\n      innerType: CsharpSupport.Types.reference(\n        CsharpSupport.classReference({\n          name: `IdentityUser`,\n          namespace: \"Microsoft.AspNetCore.Identity\",\n        })\n      ),\n    });\n\n    return files;\n  }\n\n  afterCreateControllerBase(\n    context: dotnetTypes.DsgContext,\n    eventParams: dotnet.CreateEntityControllerBaseParams,\n    files: FileMap<Class>\n  ): FileMap<Class> {\n    const { entity, apisDir, moduleActions, entities } = eventParams;\n    const { roles } = context;\n\n    const pascalPluralName = pascalCase(entity.pluralName);\n    const roleNames = roles?.map((role) => role.name).join(\",\");\n\n    const controllerBaseFile = files.get(\n      `${apisDir}/${entity.name}/Base/${pascalPluralName}ControllerBase.cs`\n    );\n\n    const methods = controllerBaseFile?.code.getMethods();\n\n    const entityRolesMap = getEntityRoleMap(entity, roleNames);\n\n    for (const moduleAction of moduleActions) {\n      switch (moduleAction.actionType) {\n        case EnumModuleActionType.Create: {\n          const createMethod = methods?.find(\n            (m) => m.name === `Create${entity.name}`\n          );\n          createMethod &&\n            createMethodAuthorizeAnnotation(\n              createMethod,\n              entityRolesMap[EnumEntityAction.Create].roles\n            );\n          break;\n        }\n        case EnumModuleActionType.Delete: {\n          const deleteMethod = methods?.find(\n            (m) => m.name === `Delete${entity.name}`\n          );\n          deleteMethod &&\n            createMethodAuthorizeAnnotation(\n              deleteMethod,\n              entityRolesMap[EnumEntityAction.Delete].roles\n            );\n          break;\n        }\n        case EnumModuleActionType.Read: {\n          const readMethod = methods?.find((m) => m.name === entity.name);\n          readMethod &&\n            createMethodAuthorizeAnnotation(\n              readMethod,\n              entityRolesMap[EnumEntityAction.View].roles //check if this is the correct type\n            );\n          break;\n        }\n        case EnumModuleActionType.Find: {\n          const findMethod = methods?.find(\n            (m) => m.name === pascalCase(entity.pluralName)\n          );\n\n          findMethod &&\n            createMethodAuthorizeAnnotation(\n              findMethod,\n              entityRolesMap[EnumEntityAction.Search].roles //check if this is the correct type\n            );\n          break;\n        }\n        case EnumModuleActionType.Update: {\n          const updateMethod = methods?.find(\n            (m) => m.name === `Update${entity.name}`\n          );\n          updateMethod &&\n            createMethodAuthorizeAnnotation(\n              updateMethod,\n              entityRolesMap[EnumEntityAction.Update].roles\n            );\n          break;\n        }\n        case EnumModuleActionType.ChildrenConnect: {\n          if (!moduleAction.fieldPermanentId) break;\n\n          const createMethod = methods?.find(\n            (m) => m.name.toLowerCase() === moduleAction.name.toLowerCase()\n          );\n\n          createMethod &&\n            createRelatedMethodAuthorizeAnnotation(\n              entity,\n              entities,\n              moduleAction.fieldPermanentId,\n              createMethod,\n              EnumEntityAction.Create,\n              roleNames\n            );\n          break;\n        }\n        case EnumModuleActionType.ChildrenDisconnect: {\n          if (!moduleAction.fieldPermanentId) break;\n\n          const createMethod = methods?.find(\n            (m) => m.name.toLowerCase() === moduleAction.name.toLowerCase()\n          );\n\n          createMethod &&\n            createMethod &&\n            createRelatedMethodAuthorizeAnnotation(\n              entity,\n              entities,\n              moduleAction.fieldPermanentId,\n              createMethod,\n              EnumEntityAction.Delete,\n              roleNames\n            );\n          break;\n        }\n        case EnumModuleActionType.ChildrenFind: {\n          if (!moduleAction.fieldPermanentId) break;\n\n          const createMethod = methods?.find(\n            (m) => m.name.toLowerCase() === moduleAction.name.toLowerCase()\n          );\n\n          createMethod &&\n            createMethod &&\n            createRelatedMethodAuthorizeAnnotation(\n              entity,\n              entities,\n              moduleAction.fieldPermanentId,\n              createMethod,\n              EnumEntityAction.Search,\n              roleNames\n            );\n          break;\n        }\n        case EnumModuleActionType.ChildrenUpdate: {\n          if (!moduleAction.fieldPermanentId) break;\n\n          const createMethod = methods?.find(\n            (m) => m.name.toLowerCase() === moduleAction.name.toLowerCase()\n          );\n\n          createMethod &&\n            createMethod &&\n            createRelatedMethodAuthorizeAnnotation(\n              entity,\n              entities,\n              moduleAction.fieldPermanentId,\n              createMethod,\n              EnumEntityAction.Update,\n              roleNames\n            );\n          break;\n        }\n        case EnumModuleActionType.Custom: {\n          const createMethod = methods?.find(\n            (m) => m.name.toLowerCase() === moduleAction.name.toLowerCase()\n          );\n          createMethod &&\n            roleNames &&\n            createMethodAuthorizeAnnotation(createMethod, roleNames);\n          break;\n        }\n      }\n    }\n\n    return files;\n  }\n\n  afterCreateControllerBaseModule(\n    context: dotnetTypes.DsgContext,\n    eventParams: dotnet.CreateControllerBaseModuleFileParams,\n    files: FileMap<Class>\n  ): FileMap<Class> {\n    const { controllerBaseModuleBasePath, moduleActionsAndDtos } = eventParams;\n    const { roles } = context;\n    const roleNames = roles?.map((role) => role.name).join(\",\");\n\n    const moduleName = moduleActionsAndDtos.moduleContainer.name;\n    const pascalPluralName = pascalCase(moduleName);\n\n    const controllerBaseFile = files.get(\n      `${controllerBaseModuleBasePath}/${moduleName}/Base/${pascalPluralName}ControllerBase.cs`\n    );\n\n    if (!controllerBaseFile) return files;\n\n    const methods = controllerBaseFile.code.getMethods();\n    roleNames &&\n      methods?.forEach((method) => {\n        createMethodAuthorizeAnnotation(method, roleNames);\n      });\n\n    return files;\n  }\n\n  afterCreateSeedDevelopmentDataFile(\n    context: dotnetTypes.DsgContext,\n    eventParams: dotnet.CreateSeedDevelopmentDataFileParams,\n    files: FileMap<Class>\n  ): FileMap<Class> {\n    const { seedFilePath, resourceName } = eventParams;\n    const { entities } = context;\n\n    if (!entities) return files;\n\n    const seedFile = files.get(seedFilePath);\n    seedFile?.code.addMethod(\n      CsharpSupport.method({\n        name: \"SeedDevUser\",\n        access: \"public\",\n        isAsync: true,\n        body: CreateSeedDevelopmentDataBody(resourceName, context),\n        type: MethodType.STATIC,\n        parameters: [\n          CsharpSupport.parameter({\n            name: \"serviceProvider\",\n            type: CsharpSupport.Types.reference(\n              CsharpSupport.classReference({\n                name: \"IServiceProvider\",\n                namespace: `${resourceName}.Infrastructure.Models`,\n              })\n            ),\n          }),\n          CsharpSupport.parameter({\n            name: \"configuration\",\n            type: CsharpSupport.Types.reference(\n              CsharpSupport.classReference({\n                name: \"IConfiguration\",\n                namespace: \"\",\n              })\n            ),\n          }),\n        ],\n      })\n    );\n\n    return files;\n  }\n}\n\nexport default AuthCorePlugin;\n"],"names":[],"sourceRoot":""}